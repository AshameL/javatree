# JVM栈

## 1、jvm规范

在jvm规范中，将栈划分为虚拟机栈和本地方法栈，分别对应与java方法的调用和本地方法的调用

### 1.1 虚拟机栈

> 每个Java虚拟机线程都有一个私有Java虚拟机堆栈，与该线程同时被创建。Java虚拟机堆栈存储着栈帧。Java虚拟机栈类似于常规语言（例如C）的堆栈：它保存局部变量和部分结果，并在方法调用和返回中起作用。因为除了pop和push帧外，并不会直接操纵Java虚拟机堆栈，所以栈帧也可以从堆中分配。Java虚拟机栈的内存不必是连续的。
>
> 该规范允许Java虚拟机堆栈具有固定大小，或者根据计算要求动态扩展和收缩。如果Java虚拟机堆栈的大小固定，则在创建每个Java虚拟机栈时可以独立选择其大小。
>
> Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈初始大小的控制，并且在动态扩展或收缩Java虚拟机堆栈的情况下，可以控制大小范围。

以上是jvm规范的描述，虚拟机栈的生命周期与线程相同，每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息，每一个方法从调用到结束，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程，下面对栈帧的结构进行介绍

#### 1.1.1 局部变量区域

> 每个栈帧都包含一个称为其**局部变量**的变量数组。栈帧的局部变量数组的长度在编译成字节码时确定
>
> 单个本地变量可以保存类型的值`boolean`，`byte`，`char`，`short`，`int`， `float`，`reference`，或`returnAddress`。类型为`long`或`double`可以通过两个局部变量保存
>
> 局部变量通过索引取值。第一个局部变量的索引为0。
>
> 类型为 `long`或`double`占用两个连续的局部变量。只能使用较小的索引来索引该值。例如，`double`存储在索引为_n_ 的局部变量数组中的类型值 实际上占据了索引为_n_和 _n_ +1 的局部变量；但是，无法从索引_n_ +1加载局部变量。它可以存储到_n_+1的位置。但是，这样做会使局部变量_n_的内容无效。
>
> Java虚拟机不需要 _n_为偶数。用直观的术语来说，类型的值`long`和 `double`不必在局部变量数组中进行64位对齐。
>
> Java虚拟机在方法调用时使用局部变量传递参数。在类方法调用时，所有参数都将从连续的局部变量（从局部变量_0_开始）传递。在调用实例方法时，局部变量0默认用于传递方法所属对象实例的引用（`java`中的`this`），随后其他参数将从局部变量_1_开始传递。

规范对局部变量的描述已经很清晰了，需要注意的是这里面定义的数据类型`reference`，`returnAddress`。

`reference`类型标示对一个对象实例的引用，规范中没有说明它的长度（长度与实际使用32还是64位虚拟机有关）和具体的结构，但是定义了有三种`reference` 类型：类类型，数组类型和接口类型，它们分别指向动态创建的类实例，数组和实现接口的类实例

`returnAddress`类型是为由Java虚拟机使用`JSR`，`RET`和`jsr_w`字节码服务的，曾被用于实现异常处理，但是在Java SE 7之后就已经被禁用了，就不管它了

#### 1.1.2 操作数栈

操作数栈是虚拟机栈帧中的一块区域，JVM的解释执行引擎被称为“**基于栈的执行引擎**“，其中的“栈“就是指**操作数栈**，与之相对的是“**基于寄存器的执行引擎**“，操比如python虚拟机等

**1.1.2.1 基于栈的执行引擎**

以一个简单的例子来描述什么是基于栈的执行引擎：当虚拟机要完成类似`a = b + c`这样的操作时，它会怎么做呢，对于**基于栈的执行引擎（如jvm）**而言，它可能会将其转换成这种形式的字节码：

```text
iconst_1  
iconst_2  
iadd      
istore_0  
```

初看会感觉有些莫名其妙，尤其是`iadd`指令，光秃秃的，**源**和**目标**都没有，这种指令一般称为**零地址指令**，意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构，**栈**。

上面的`iconst_1、iconst_2`两条指令，分别向一个叫做“**操作数栈**”\(也被称为**求值栈**\)的地方压入局部变量1和局部变量2的值，然后`iadd`指令将栈顶的两个值相加后放回栈顶，istore\_0指令将栈顶的值放会局部变量0的位置

```text
iconst_1   # 将局部变量0压入栈
iconst_2   # 将局部变量1压入栈
iadd       # 将栈顶的两个值弹出，相加后再压入栈 
istore_0   # 将栈顶的值放回局部变量0
```

由于指令的源与目标都是隐含的，则一条零地址指令的长度可以很短，意味着可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令的缺陷也很明显，要完成一件事情，一般需要比二地址或者三地址指令更多条指令。上面Java字节码做的加法，如果用x86指令，三条就能完成了：

```text
X86 asm代码:
mov  eax, [1]  #将变量1放入寄存器eax  
add  eax, [2]  #将eax与变量2相加后放入寄存器eax
mov  [0], eax  #将eax的值放回变量0
```



**1.1.2.2 基于寄存器的执行引擎**



**1.1.2.3 基于寄存器与基于栈的对比**



#### 1.1.3 运行环境区

### 1.2 本地方法栈

> Java虚拟机的实现可以使用传统的堆栈（俗称“ C栈”）来支持本地方法（用Java编程语言以外的语言编写的方法），解释程序的实现也可以使用诸如C之类的语言来解释Java虚拟机的指令集，以使用本地方法栈。无法加载本地方法并且自身不依赖于常规堆栈的Java虚拟机实现无需提供本地方法栈。如果提供，通常在创建每个线程时为每个线程分配本地方法栈。

以上是jvm规范的翻译节选，其他部分基本与java虚拟机栈一致，从中可以看出规范中有两类程序会用到本地方法栈：

* 运行java以外的编程语言编写的方法时，会用到本地方法栈
* jvm本身可能使用C之类的语言来实现的，所以也可能会用到本地方法栈

## 2、hotspot实现

在hotspot的实现中，**本地方法栈和虚拟机栈共用一个栈**（mixed-stack），区别仅在于本地方法和java方法产生的栈帧不同，此外，在linux中，混合栈是通过**轻量级线程的用户栈**来实现的，可以这么认为，**轻量级线程的用户栈中的栈帧就是一个个的java方法栈帧和native方法栈帧，**可以通过jstack命令来直观进行理解：

任意跑一个java代码，使用命令 `jstack -m {pid}`即可看到混合栈的信息：

```text
0x00007f2305c90da2	__pthread_cond_timedwait + 0x132
0x00007f2304dd18f3	_ZN2os5sleepEP6Threadlb + 0x283
0x00007f2304bcebda	JVM_Sleep + 0x3ba
0x00007f22f05a79b4	* java.lang.Thread.sleep(long) bci:0 (Interpreted frame)
0x00007f22f05982bd	* MainTest.main(java.lang.String[]) bci:49 line:40 (Interpreted frame)
0x00007f22f05907a7	<StubRoutines>
0x00007f2304b3bd16	_ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread + 0x1056
0x00007f2304b7d132	_ZL17jni_invoke_staticP7JNIEnv_P9JavaValueP8_jobject11JNICallTypeP10_jmethodIDP18JNI_ArgumentPusherP6Thread + 0x362
0x00007f2304b9999a	jni_CallStaticVoidMethod + 0x17a
0x00007f2305a76bdf	JavaMain + 0x81f
```

上图截取了一部分信息，地址右边的这一串就是混合栈中的栈帧，其中，以`*`开头的代表这是个**java栈帧**，其它的则是**本地方法栈帧。**

### **2.1 栈\(mixed-stack\)的创建**

我们知道，在linux环境下，jvm的线程是通过**轻量级进程\(LWP\)**来实现的，而进程在创建LWP时需要给它分配栈空间（[前置知识](../pre-knowledge.md#21-qing-liang-ji-jin-cheng-lwp-de-di-zhi-kong-jian)），那么，对于Hotspot进程而言，它是如何分配栈空间的呢，追下源码：

```cpp
bool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size){
     ...
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
     ...
}

```

在Os\_linux.cpp文件下，hotspot最终调用了pthread库的phtread\_create\(\)方法来创建LWP，代码中`&attr`会提供创建栈的参数，追一追代码最终发现，hotspot并没有往这个参数中放分配好的栈地址，而**只是放了需要的栈大小**

再追一追pthread库的代码，发现如果调用`pthread_create()`方法时不指定地址，那么将默认调用mmap\(\)方法（ [前置知识](../pre-knowledge.md#3-1-1-mmap)）从进程中分配一块**内存映射空间**作为LWP的栈空间

至此，hotspot涉及到的栈相关的概念就都清楚了





