---
description: linux进程虚拟地址空间
---

# 前置知识

在介绍JVM运行时数据区时会涉及到一些底层的实现，这部分与Linux进程密切相关， 读懂本章的内容有助于后续内容的理解

## 1、Linux进程空间划分

![](https://upload-images.jianshu.io/upload_images/18927149-ec955894929bcb8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### **1.1 程序代码和数据**

对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置，代码和数据区是直接按照可执行目标文件的内容初始化的

### **1.2 堆**

代码和数据区后紧跟随的是运行时堆，代码和数据区在进程一开始运行时就被指定了大小，与此不同，一般当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态的扩展和收缩

### **1.3 共享库的内存映射区**

大约在地址空间的中间部分时一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域，本区域与jvm关系较为密切，接下来会详细进行描述：

> linux将通过将一个虚拟内存区域与一个磁盘上的对象\(object\)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping）。虚拟内存区域可以映射到两种类型的对象中的一种：
>
> 1、Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有施小计交换进入物理内存，直到cpu第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。
>
> 2、匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。cpu第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，竞这个页面标记为时驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件中区域中的页面有时也叫做请求二进制零的页

以上是《深入理解计算机系统》中的描述，可以这么理解，例如每个C程序都需要来自标准C库的诸如printf这样的函数，那么如果每个进程都在物理内存中保持这些常用代码的副本，这样就太浪费了，内存映射就可以解决这个问题，即让多个进程不同的虚拟地址区域映射到同一片物理内存区域上，这样就能让多个进程共享这些库。 

当然，这样会引发一个问题，假如这个库被多个进程所共享，确实可以节省物理空间，但貌似会进程间互相干扰的情况，如果某种场景进程不希望这个库被其他进程修改，那该如何处理呢？ 

很简单，进程进行内存映射的时候可以指定是私有对象还是共享对象，如果是私有对象，那么会运用到**写时复制技术**，只要没有进程试图写它自己的私有对象，那么进程们还可以继续共享物理内存中对象的一个单独副本，然而，只要有一个进程试图对其进行修改，那么该进程就自己在物理内存中创建一个副本，然后修改，这样就不会影响到其他进程

再看匿名文件的映射，从用途上看，在映射前，并不存在这么个真实的文件，自然不是为了共享库，那么显然是为了方便进程间的通信，为了直观一点了解内存映射，下面简单做了个实验：

在linux环境下跑了一个java程序，那么可以根据pmap工具来查看它的虚拟地址空间：

**pmap {进程id}**    , 节选了一小段

```text
00007f22ffffe000      4K r---- librt-2.17.so
00007f22fffff000      4K rw--- librt-2.17.so
00007f2300000000    864K rw---   [ anon ]
00007f23000d8000  64672K -----   [ anon ]
00007f230402f000   1508K rw---   [ anon ]
```

以上 \[anon\]对应的地址就是匿名文件对应的内存映射了，librt-2.17.so对应是就是共享库的内存映射\(SO文件格式即ELF文件格式,它是Linux下可执行文件,共享库文件和目标文件的统一格式\)

### **1.4 栈**

位于用户虚拟空间顶部的时用户栈，编译器用它来实现函数调用，和堆一样，用户栈在程序执行期间可以动态地扩展和收缩，特别的，每次当我们调用一个函数时，栈就会增长，从一个函数返回时，栈就会收缩

### **1.5 内核虚拟内存**

地址空间顶部的区域是为内存保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数，相反，它们必须调用内核来执行这些操作

## 2、linux 进程、轻量级进程的地址空间

首先明确一点，进程、线程是操作系统里的抽象概念，在早期的Linux中，多线程应用程序在内核看来仅仅是一个普通进程，多线程应用程序多个执行流的创建、处理、调度整个都是在用户态进行的，但是这种多线程实现方式有很大的缺陷，一旦某个进程被阻塞，其他线程也将被阻塞\(线程调度发生在用户态，与内核的进程调度无关\)，所以必须使用复杂的非阻塞技术来确保进程仍然是可运行的。 现代Linux内核使用轻量级进程（LWP）来对多线程应用程序提供更好的支持，一个简单的方式就是把轻量级进程与每个线程关联起来，这样，每个线程都可以由内核独立调度，以便一个阻塞的同时另一个仍然是运行的（是的，hopspot就是这么干的）

### 2.1 轻量级进程\(LWP\)的地址空间

轻量级进程通过clone\(\)系统调用来进行创建，它有以下特性： 1、LWP之间共用同一个地址空间\(虚拟地址\) 2、LWP拥有独立的栈，栈空间需由进程分配 第一点很好理解，与操作系统中线程与进程的关系一致，主要解释以下第二点： 对于一个进程而言，如果需要创建一个LWP，显然LWP需要一个自己独立的用户栈，不能直接用进程的用户栈（栈是用来实现函数调用的，通过rsp寄存器来标识，而线程和LWP执行的代码都不一样，必然得相互独立） 那么就需要进程分配一段空间给LWP作为用户栈空间，分配的方式没有限制，可以从系统堆里分配，也可以申请一块内存映射来分配，具体到代码层面就是调用clone\(\)方法时需传入栈的地址

### 2.2 进程的地址空间

进程通过fork\(\)系统调用来进行创建，进程之间的地址空间是独立的，是通过写时复制技术实现的：即允许父子进程读相同的物理页，只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程

## 3、Linux进程分配空间的方式

可以从两个层面来看，一是系统调用层，二是C标准库层

### **3.1系统调用层**

linux分配内存是通mmap\(\)和brk\(\)这两个系统调用来完成的

#### **3.1.1 mmap\(\)**

mmap\(\)系统调用主要是创建一个文件的内存映射，从而扩大进程的地址空间，可以分为共享库的内存映射和匿名文件的内存映射，1.3节有较详细的介绍

#### **3.1.1 brk\(\)**

brk\(\)系统调用主要是通过修改brk指针，来改变进程堆的大小，可以结合着看文章开头的空间分布图，brk指针指向的是堆的顶部地址

### **3.2 C标准库层**

#### **3.2.1 malloc\(\)函数**

这是我们写C程序经常会用到的函数，它的底层逻辑大体是这样的：

* 小于128k的内存，使用brk\(\)系统调用
* 大于128k的内存，使用mmap\(\)系统调用

所以使用malloc\(\)函数不一定就是从堆中分配的哦

#### **3.2.2 mmap\(\)函数\(与系统调用同名\)**

C标准库中封装一个同名的mmap\(\)函数，底层便是使用的mmap\(\)系统调用



参考书籍：《深入理解计算机系统》、《深入理解linux内核》

![](../../.gitbook/assets/image%20%2815%29.png)

