# 栈

## 1、jvm规范

在jvm规范中，将栈划分为虚拟机栈和本地方法栈，分别对应与java方法的调用和本地方法的调用

### 1.1 虚拟机栈

> 每个Java虚拟机线程都有一个私有Java虚拟机堆栈，与该线程同时被创建。Java虚拟机堆栈存储着栈帧。Java虚拟机栈类似于常规语言（例如C）的堆栈：它保存局部变量和部分结果，并在方法调用和返回中起作用。因为除了pop和push帧外，并不会直接操纵Java虚拟机堆栈，所以栈帧也可以从堆中分配。Java虚拟机栈的内存不必是连续的。
>
> 该规范允许Java虚拟机堆栈具有固定大小，或者根据计算要求动态扩展和收缩。如果Java虚拟机堆栈的大小固定，则在创建每个Java虚拟机栈时可以独立选择其大小。
>
> Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈初始大小的控制，并且在动态扩展或收缩Java虚拟机堆栈的情况下，可以控制大小范围。

以上是jvm规范的描述，虚拟机栈的生命周期与线程相同，每个方法在执行的同时都会创建几个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到结束，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程，下面对栈帧的结构进行介绍

#### 1.1.1 操作数区



#### 1.1.1 局部变量区域

> 每个栈帧都包含一个称为其**局部变量**的变量数组。栈帧的局部变量数组的长度在编译成字节码时确定
>
> 单个本地变量可以保存类型的值`boolean`，`byte`，`char`，`short`，`int`， `float`，`reference`，或`returnAddress`。类型为`long`或`double`可以通过两个局部变量保存
>
> 局部变量通过索引取值。第一个局部变量的索引为0。
>
> 类型为 `long`或`double`占用两个连续的局部变量。只能使用较小的索引来索引该值。例如，`double`存储在索引为_n_ 的局部变量数组中的类型值 实际上占据了索引为_n_和 _n_ +1 的局部变量；但是，无法从索引_n_ +1加载局部变量。它可以存储到_n_+1的位置。但是，这样做会使局部变量_n_的内容无效。
>
> Java虚拟机不需要 _n_为偶数。用直观的术语来说，类型的值`long`和 `double`不必在局部变量数组中进行64位对齐。
>
> Java虚拟机在方法调用时使用局部变量传递参数。在类方法调用时，所有参数都将从连续的局部变量（从局部变量_0_开始）传递。在调用实例方法时，局部变量0默认用于传递方法所属对象实例的引用（`java`中的`this`），随后其他参数将从局部变量_1_开始传递。

规范对局部变量的描述已经很清晰了，需要注意的是这里面定义的数据类型`reference`，`returnAddress`。

`reference`类型标示对一个对象实例的引用，规范中没有说明它的长度（长度与实际使用32还是64位虚拟机有关）和具体的结构，但是定义了有三种`reference` 类型：类类型，数组类型和接口类型，它们分别指向动态创建的类实例，数组和实现接口的类实例

`returnAddress`类型是为由Java虚拟机使用`JSR`，`RET`和`jsr_w`字节码服务的，曾被用于实现异常处理，但是在Java SE 7之后就已经被禁用了，就不管它了

#### 1.1.2 操作数栈

JVM的解释执行引擎是“基于栈的执行引擎“，其中的“栈“就是指操作数栈，与之相对的是“基于寄存器的执行引擎“，比如python虚拟机，后文会对二者进行比较



1.1.2.1 

#### 1.1.3 运行环境区

### 1.2 本地方法栈

> Java虚拟机的实现可以使用传统的堆栈（俗称“ C栈”）来支持本地方法（用Java编程语言以外的语言编写的方法），解释程序的实现也可以使用诸如C之类的语言来解释Java虚拟机的指令集，以使用本地方法栈。无法加载本地方法并且自身不依赖于常规堆栈的Java虚拟机实现无需提供本地方法栈。如果提供，通常在创建每个线程时为每个线程分配本地方法堆栈。

以上是jvm规范的翻译节选，其他部分基本与java虚拟机栈一致，从中可以看出规范中有两类程序会用到本地方法栈：

* 运行java以外的编程语言编写的方法时，会用到本地方法栈
* jvm本身可能使用C之类的语言来实现的，所以也可能会用到本地方法栈

## 2、hotspot实现

