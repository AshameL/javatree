顺序一致性内存模型是一个被计算机科学家**理想化**了的理论参考模型，像一个基准点。在设计的时候，处理器级别的内存模型和编程语言级别的内存模型都会以顺序一致性模型作为参照。

> 顺序一致性模型的定义：
> 在顺序一致性里，所有动作以全序（执行顺序）的顺序发生，与程序顺序一致；而且，每个对变量 v 的读操作 r 都将看到写操作 w 写入 v 的值，只要:
>
> - 执行顺序上 w 在 r 之前，且
> - 执行顺序上不存在这样一个 w' ，w 在 w' 之前且 w' 在 r 之前。

我们来更直白地理解。顺序一致性内存模型的特征：

- 所有动作存在一个全序关系，与程序的顺序一致；
- 每个动作都是原子的；
- 每个动作执行后立即对所有线程可见；

其实就是严格遵守了顺序性、原子性、可见性。

可以理解为顺序一致性模型有一个单一的全局内存，这个内存在任一时刻只能够连接到一个线程，同时每一个线程必须按照程序的顺序来执行读写内存的操作（是不是忽然想到了MySQL的串行化，这个后文来做横向概念类比）。

之所以说顺序一致性模型是一个理想模型，是因为它虽然能够保证正确，但是效率太低了。如果将顺序一致性作为实际内存模型，之前讨论的编译器和处理器优化将不再合法。现实中的处理器和语言都是在顺序一致性模型的基础上，为了执行效率优化，做了不同程度的执行顺序牺牲。

具体到JMM，对于正确同步（按照JMM同步规则进行代码编写）的程序，会保证程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。可以说这对于开发者来讲是一个极强的保证。

对于未正确同步的程序，整体执行上是无需的，其执行结果是无法预知的。包括不保证对64位的 long 型和 double 型变量的写操作具有原子性。JMM仅能够保证最小安全性，即线程读到的值要么是之前某个线程写入的，要么是默认值（0 或 null 或 false），不会无中生有地出现。为了实现这个最小安全性，JMM会在堆上分配对象前对该内存空间初始化。